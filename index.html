<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Procedural 3D Optimized</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#87ceeb;touch-action:none;}
#ui{position:fixed;bottom:20px;left:20px;width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.15);border:2px solid rgba(255,255,255,0.4);}
#stick{position:absolute;left:40px;top:40px;width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.7);}
#info{position:fixed;top:10px;left:10px;font-family:monospace;color:#fff;background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:6px;}
</style>
</head>
<body>
<div id="info">Optimized Procedural World üåç<br>PC + Mobile</div>
<div id="ui"><div id="stick"></div></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
/* =========================
   SCENA + KAMERA
========================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87ceeb,50,300);
const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,20,40);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setClearColor(0x87ceeb);
document.body.appendChild(renderer.domElement);

/* =========================
   ≈öWIAT≈ÅO
========================= */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(100,200,100);
scene.add(sun);

/* =========================
   TEKSTURY SVG 512x512
========================= */
function svgTexture(c1,c2){
  const s=512;
  const svg=`<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}">
    <defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="${c1}"/>
      <stop offset="100%" stop-color="${c2}"/>
    </linearGradient></defs>
    <rect width="100%" height="100%" fill="url(#g)"/>
  </svg>`;
  const img=new Image();
  const canvas=document.createElement("canvas");
  canvas.width=canvas.height=s;
  const ctx=canvas.getContext("2d");
  return new Promise(r=>{
    img.onload=()=>{
      ctx.drawImage(img,0,0);
      const t=new THREE.CanvasTexture(canvas);
      t.wrapS=t.wrapT=THREE.RepeatWrapping;
      t.repeat.set(8,8);
      r(t);
    }
    img.src="data:image/svg+xml;base64,"+btoa(svg);
  });
}

/* =========================
   NOISE
========================= */
function noise(x,z){return Math.sin(x*0.08)+Math.cos(z*0.08)+Math.sin((x+z)*0.04);}

/* =========================
   CHUNK SYSTEM
========================= */
const CHUNK_SIZE=50;
const RENDER_DISTANCE=2;
const chunks=new Map();
const trees = [];

async function generateChunk(cx,cz){
  const key = cx+","+cz;
  if(chunks.has(key)) return;
  const geo = new THREE.PlaneGeometry(CHUNK_SIZE,CHUNK_SIZE,25,25);
  geo.rotateX(-Math.PI/2);
  const p = geo.attributes.position;
  for(let i=0;i<p.count;i++){
    const x=p.getX(i)+cx*CHUNK_SIZE;
    const z=p.getZ(i)+cz*CHUNK_SIZE;
    p.setY(i,noise(x,z)*6 + Math.random()*0.5);
  }
  geo.computeVertexNormals();

  const tex = await svgTexture("#2e7d32","#66bb6a");
  const mat = new THREE.MeshStandardMaterial({map:tex});
  const mesh = new THREE.Mesh(geo,mat);
  mesh.position.set(cx*CHUNK_SIZE,0,cz*CHUNK_SIZE);
  scene.add(mesh);

  // drzewa
  const trunkMat=new THREE.MeshStandardMaterial({color:0x6d4c41});
  const leafMat=new THREE.MeshStandardMaterial({color:0x2e7d32});
  for(let i=0;i<10;i++){
    const x=(Math.random()-0.5)*CHUNK_SIZE + cx*CHUNK_SIZE;
    const z=(Math.random()-0.5)*CHUNK_SIZE + cz*CHUNK_SIZE;
    const y = noise(x,z)*6;
    const trunk=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.7,5),trunkMat);
    trunk.position.set(x,y+2.5,z);
    const leaves=new THREE.Mesh(new THREE.SphereGeometry(3,6,6),leafMat);
    leaves.position.set(x,y+6,z);
    scene.add(trunk,leaves);
    trees.push(trunk,leaves);
  }

  chunks.set(key,mesh);
}

let lastChunkUpdate=0;
function updateChunks(delta){
  lastChunkUpdate+=delta;
  if(lastChunkUpdate<0.3) return;
  lastChunkUpdate=0;

  const cx=Math.floor(camera.position.x/CHUNK_SIZE);
  const cz=Math.floor(camera.position.z/CHUNK_SIZE);
  for(let x=cx-RENDER_DISTANCE;x<=cx+RENDER_DISTANCE;x++){
    for(let z=cz-RENDER_DISTANCE;z<=cz+RENDER_DISTANCE;z++){
      generateChunk(x,z);
    }
  }
  for(let key of chunks.keys()){
    const [x,z]=key.split(',').map(Number);
    if(Math.abs(x-cx)>RENDER_DISTANCE || Math.abs(z-cz)>RENDER_DISTANCE){
      const mesh=chunks.get(key);
      scene.remove(mesh);
      chunks.delete(key);
    }
  }
}

/* =========================
   CHMURY
========================= */
const clouds=[];
function cloud(){
  const g=new THREE.SphereGeometry(5,6,6);
  const m=new THREE.MeshStandardMaterial({color:0xffffff});
  const c=new THREE.Mesh(g,m);
  c.position.set((Math.random()-0.5)*300,80+Math.random()*40,(Math.random()-0.5)*300);
  clouds.push(c);
  scene.add(c);
}
for(let i=0;i<8;i++) cloud();

/* =========================
   JOYSTICK
========================= */
const ui=document.getElementById("ui");
const stick=document.getElementById("stick");
let joy={x:0,y:0};
ui.addEventListener("touchmove",e=>{
  const r=ui.getBoundingClientRect();
  const t=e.touches[0];
  let x=t.clientX-(r.left+r.width/2);
  let y=t.clientY-(r.top+r.height/2);
  const max=40;
  const d=Math.hypot(x,y);
  if(d>max){ x*=max/d; y*=max/d; }
  stick.style.left=40+x+"px";
  stick.style.top=40+y+"px";
  joy.x=x/max; joy.y=y/max;
});
ui.addEventListener("touchend",()=>{stick.style.left="40px"; stick.style.top="40px"; joy.x=joy.y=0;});

/* =========================
   DOTYK DO OBRACANIA
========================= */
let prevX=null,prevY=null,rotX=0,rotY=0;
renderer.domElement.addEventListener("touchstart",e=>{
  if(e.touches.length===1){ prevX=e.touches[0].clientX; prevY=e.touches[0].clientY; }
});
renderer.domElement.addEventListener("touchmove",e=>{
  if(e.touches.length===1){
    const dx=e.touches[0].clientX-prevX;
    const dy=e.touches[0].clientY-prevY;
    rotY -= dx*0.002; rotX -= dy*0.002;
    rotX=Math.max(-Math.PI/2,Math.min(Math.PI/2,rotX));
    camera.rotation.set(rotX,rotY,0);
    prevX=e.touches[0].clientX; prevY=e.touches[0].clientY;
  }
});

/* =========================
   PC STEROWANIE
========================= */
const move={f:0,b:0,l:0,r:0};
window.addEventListener("keydown",e=>{
  if(e.key==="w") move.f=1;if(e.key==="s") move.b=1;if(e.key==="a") move.l=1;if(e.key==="d") move.r=1;
});
window.addEventListener("keyup",e=>{
  if(e.key==="w") move.f=0;if(e.key==="s") move.b=0;if(e.key==="a") move.l=0;if(e.key==="d") move.r=0;
});
let mouseDown=false;
window.addEventListener("mousedown",()=>mouseDown=true);
window.addEventListener("mouseup",()=>mouseDown=false);
window.addEventListener("mousemove",e=>{
  if(mouseDown){rotY -= e.movementX*0.002;rotX -= e.movementY*0.002; rotX=Math.max(-Math.PI/2,Math.min(Math.PI/2,rotX)); camera.rotation.set(rotX,rotY,0);}
});

/* =========================
   RUCH
========================= */
function moveCamera(delta){
  const speed=0.6;
  const dir=new THREE.Vector3();
  camera.getWorldDirection(dir);
  dir.y=0; dir.normalize();
  camera.position.add(dir.clone().multiplyScalar(joy.y*speed + (move.f-move.b)*speed));
  camera.position.add(new THREE.Vector3(dir.z,0,-dir.x).multiplyScalar(joy.x*speed + (move.r-move.l)*speed));
}

/* =========================
   LOOP
========================= */
let lastTime=0;
function animate(time){
  requestAnimationFrame(animate);
  const delta=(time-lastTime)/1000;
  lastTime=time;

  moveCamera(delta);
  updateChunks(delta);

  clouds.forEach(c=>{c.position.x+=0.02; if(c.position.x>200) c.position.x=-200;});
  renderer.render(scene,camera);
}
animate();

/* =========================
   RESIZE
========================= */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>