<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MiniCraft 3D HTML</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#87ceeb;touch-action:none;}
#ui{position:fixed;bottom:20px;left:20px;width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.15);border:2px solid rgba(255,255,255,0.4);}
#stick{position:absolute;left:40px;top:40px;width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.7);}
#inventory{position:fixed;bottom:20px;right:20px;width:200px;height:120px;background:rgba(0,0,0,0.5);color:#fff;font-family:monospace;padding:10px;overflow:auto;border-radius:6px;}
#info{position:fixed;top:10px;left:10px;font-family:monospace;color:#fff;background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:6px;}
</style>
</head>
<body>
<div id="info">MiniCraft 3D üåç<br>PC + Mobile</div>
<div id="ui"><div id="stick"></div></div>
<div id="inventory">Ekwipunek:<br><span id="items">Brak</span></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
/* =========================
   SCENA + KAMERA
========================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87ceeb,50,300);
const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,5,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setClearColor(0x87ceeb);
document.body.appendChild(renderer.domElement);

/* =========================
   ≈öWIAT≈ÅO
========================= */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(100,200,100);
scene.add(sun);

/* =========================
   NOISE + TERRAIN
========================= */
function noise(x,z){return Math.sin(x*0.08)+Math.cos(z*0.08)+Math.sin((x+z)*0.04);}
function terrainHeight(x,z){return noise(x,z)*2 + Math.random()*0.3;}

/* =========================
   VOXEL CHUNK SYSTEM
========================= */
const CHUNK_SIZE = 16;
const RENDER_DISTANCE = 2;
const chunks = new Map();
const blocks = [];
const trees = [];

async function createChunk(cx,cz){
  const key=cx+","+cz;
  if(chunks.has(key)) return;

  const material = new THREE.MeshStandardMaterial({color:0x2e7d32});
  const chunkGroup = new THREE.Group();

  for(let x=0;x<CHUNK_SIZE;x++){
    for(let z=0;z<CHUNK_SIZE;z++){
      const worldX = x + cx*CHUNK_SIZE;
      const worldZ = z + cz*CHUNK_SIZE;
      const y = terrainHeight(worldX,worldZ);
      const geo = new THREE.BoxGeometry(1,1,1);
      const mesh = new THREE.Mesh(geo,material);
      mesh.position.set(worldX,Math.floor(y),worldZ);
      chunkGroup.add(mesh);
      blocks.push(mesh);

      // 1/8 szansa na drzewo
      if(Math.random()<0.125){
        const trunkMat=new THREE.MeshStandardMaterial({color:0x6d4c41});
        const leafMat=new THREE.MeshStandardMaterial({color:0x2e7d32});
        const trunk=new THREE.Mesh(new THREE.BoxGeometry(0.5,3,0.5),trunkMat);
        trunk.position.set(worldX,Math.floor(y)+1.5,worldZ);
        const leaves=new THREE.Mesh(new THREE.BoxGeometry(2,2,2),leafMat);
        leaves.position.set(worldX,Math.floor(y)+3.5,worldZ);
        chunkGroup.add(trunk,leaves);
        trees.push(trunk,leaves);
      }
    }
  }

  scene.add(chunkGroup);
  chunks.set(key,chunkGroup);
}

let lastChunkUpdate=0;
function updateChunks(delta){
  lastChunkUpdate+=delta;
  if(lastChunkUpdate<0.3) return;
  lastChunkUpdate=0;

  const cx=Math.floor(camera.position.x/CHUNK_SIZE);
  const cz=Math.floor(camera.position.z/CHUNK_SIZE);
  for(let x=cx-RENDER_DISTANCE;x<=cx+RENDER_DISTANCE;x++){
    for(let z=cz-RENDER_DISTANCE;z<=cz+RENDER_DISTANCE;z++){
      createChunk(x,z);
    }
  }
  // usu≈Ñ dalekie chunki
  for(let key of chunks.keys()){
    const [x,z] = key.split(',').map(Number);
    if(Math.abs(x-cx)>RENDER_DISTANCE || Math.abs(z-cz)>RENDER_DISTANCE){
      const group = chunks.get(key);
      scene.remove(group);
      chunks.delete(key);
    }
  }
}

/* =========================
   CHMURY
========================= */
const clouds=[];
function cloud(){
  const g=new THREE.SphereGeometry(2,6,6);
  const m=new THREE.MeshStandardMaterial({color:0xffffff});
  const c=new THREE.Mesh(g,m);
  c.position.set((Math.random()-0.5)*50,10+Math.random()*10,(Math.random()-0.5)*50);
  clouds.push(c);
  scene.add(c);
}
for(let i=0;i<8;i++) cloud();

/* =========================
   JOYSTICK
========================= */
const ui=document.getElementById("ui");
const stick=document.getElementById("stick");
let joy={x:0,y:0};
ui.addEventListener("touchmove",e=>{
  const r=ui.getBoundingClientRect();
  const t=e.touches[0];
  let x=t.clientX-(r.left+r.width/2);
  let y=t.clientY-(r.top+r.height/2);
  const max=40;
  const d=Math.hypot(x,y);
  if(d>max){ x*=max/d; y*=max/d; }
  stick.style.left=40+x+"px";
  stick.style.top=40+y+"px";
  joy.x=x/max; joy.y=y/max;
});
ui.addEventListener("touchend",()=>{stick.style.left="40px"; stick.style.top="40px"; joy.x=joy.y=0;});

/* =========================
   DOTYK DO OBRACANIA
========================= */
let prevX=null,prevY=null,rotX=0,rotY=0;
renderer.domElement.addEventListener("touchstart",e=>{
  if(e.touches.length===1){ prevX=e.touches[0].clientX; prevY=e.touches[0].clientY; }
});
renderer.domElement.addEventListener("touchmove",e=>{
  if(e.touches.length===1){
    const dx=e.touches[0].clientX-prevX;
    const dy=e.touches[0].clientY-prevY;
    rotY -= dx*0.002; rotX -= dy*0.002;
    rotX=Math.max(-Math.PI/2,Math.min(Math.PI/2,rotX));
    camera.quaternion.setFromEuler(new THREE.Euler(rotX,rotY,0,'YXZ'));
    prevX=e.touches[0].clientX; prevY=e.touches[0].clientY;
  }
});

/* =========================
   PC STEROWANIE
========================= */
const move={f:0,b:0,l:0,r:0};
window.addEventListener("keydown",e=>{
  if(e.key==="w") move.f=1;if(e.key==="s") move.b=1;if(e.key==="a") move.l=1;if(e.key==="d") move.r=1;
});
window.addEventListener("keyup",e=>{
  if(e.key==="w") move.f=0;if(e.key==="s") move.b=0;if(e.key==="a") move.l=0;if(e.key==="d") move.r=0;
});
let mouseDown=false;
window.addEventListener("mousedown",()=>mouseDown=true);
window.addEventListener("mouseup",()=>mouseDown=false);
window.addEventListener("mousemove",e=>{
  if(mouseDown){rotY -= e.movementX*0.002;rotX -= e.movementY*0.002; rotX=Math.max(-Math.PI/2,Math.min(Math.PI/2,rotX)); camera.quaternion.setFromEuler(new THREE.Euler(rotX,rotY,0,'YXZ'));}
});

/* =========================
   RUCH PO TERENIE + GRAWITACJA
========================= */
const playerHeight=1.6;
let velocityY=0;
const gravity=-9.8;

function moveCamera(delta){
  const speed=3*delta*10; // normalizacja
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const right=new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();

  const moveVec=forward.clone().multiplyScalar((move.f - move.b + joy.y)*speed)
                  .add(right.clone().multiplyScalar((move.r - move.l + joy.x)*speed));

  camera.position.add(moveVec);

  // poruszanie po terenie
  const yTerrain=terrainHeight(camera.position.x,camera.position.z) + playerHeight;
  if(camera.position.y > yTerrain){
    velocityY += gravity * delta;
    camera.position.y += velocityY;
    if(camera.position.y < yTerrain){camera.position.y=yTerrain; velocityY=0;}
  }else{
    camera.position.y = yTerrain;
    velocityY=0;
  }
}

/* =========================
   KOPANIE BLOK√ìW
========================= */
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
const inventory={};

function updateInventory(){
  const el=document.getElementById("items");
  el.innerText=Object.keys(inventory).map(k=>`${k}: ${inventory[k]}`).join(", ") || "Brak";
}

renderer.domElement.addEventListener("click",e=>{
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const intersects=raycaster.intersectObjects(blocks);
  if(intersects.length>0){
    const block=intersects[0].object;
    scene.remove(block);
    blocks.splice(blocks.indexOf(block),1);
    inventory['ziemia']=(inventory['ziemia']||0)+1;
    updateInventory();
  }
});

/* =========================
   PƒòTLA ANIMACJI
========================= */
let lastTime=0;
function animate(time){
  requestAnimationFrame(animate);
  const delta=(time-lastTime)/1000;
  lastTime=time;

  moveCamera(delta);
  updateChunks(delta);

  clouds.forEach(c=>{c.position.x+=0.01; if(c.position.x>50) c.position.x=-50;});
  // delikatne ko≈Çysanie drzew
  trees.forEach((t,i)=>{t.rotation.z=Math.sin(time*0.001+i)*0.05;});

  renderer.render(scene,camera);
}
animate();

/* =========================
   RESIZE
========================= */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>